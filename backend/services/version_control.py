"""\nGit-like Version Control Service for Devora Projects\n\nThis service provides version control functionality for project files, including:\n- Creating commits with file snapshots\n- Viewing commit history\n- Restoring to previous versions\n- Computing and viewing diffs between versions\n\nThe service uses MongoDB for persistent storage and supports async operations.\n"""\n\nfrom typing import List, Dict, Optional, Any\nfrom datetime import datetime, timezone\nfrom uuid import uuid4\nimport difflib\nimport logging\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom motor.motor_asyncio import AsyncIOMotorDatabase\n\nlogger = logging.getLogger(__name__)\n\n\nclass FileSnapshot(BaseModel):\n    """Represents a file at a specific point in time"""\n    model_config = ConfigDict(extra="ignore")\n\n    name: str = Field(..., description="File path/name")\n    content: str = Field(..., description="File content at this version")\n    language: Optional[str] = Field(None, description="Programming language/file type")\n\n\nclass FileDiff(BaseModel):\n    """Represents the diff for a modified file"""\n    model_config = ConfigDict(extra="ignore")\n\n    name: str = Field(..., description="File name")\n    diff_lines: List[str] = Field(default=[], description="Unified diff lines")\n    additions: int = Field(default=0, description="Number of lines added")\n    deletions: int = Field(default=0, description="Number of lines deleted")\n\n\nclass CommitDiff(BaseModel):\n    """Represents the diff between commits"""\n    model_config = ConfigDict(extra="ignore")\n\n    added: List[str] = Field(default=[], description="Names of new files")\n    modified: List[FileDiff] = Field(default=[], description="Modified files with diffs")\n    deleted: List[str] = Field(default=[], description="Names of deleted files")\n    unchanged: List[str] = Field(default=[], description="Names of unchanged files")\n    stats: Dict[str, int] = Field(\n        default_factory=lambda: {"files_changed": 0, "additions": 0, "deletions": 0},\n        description="Summary statistics"\n    )\n\n\nclass CommitCreate(BaseModel):\n    """Schema for creating a new commit"""\n    message: str = Field(..., min_length=1, max_length=500, description="Commit message")\n    files: List[Dict[str, Any]] = Field(..., description="Current files snapshot")\n\n\nclass Commit(BaseModel):\n    """Represents a single commit in the project history"""\n    model_config = ConfigDict(extra="ignore")\n\n    id: str = Field(default_factory=lambda: str(uuid4()), description="Unique commit ID")\n    project_id: str = Field(..., description="Associated project ID")\n    message: str = Field(..., description="Commit message describing changes")\n    author_id: str = Field(..., description="ID of user who made the commit")\n    author_email: Optional[str] = Field(None, description="Email of the author")\n    parent_id: Optional[str] = Field(None, description="ID of parent commit (None for first commit)")\n    files_snapshot: List[Dict[str, Any]] = Field(\n        default=[],\n        description="Complete snapshot of all files at this commit"\n    )\n    diff: Dict[str, Any] = Field(\n        default_factory=dict,\n        description="Diff from parent commit"\n    )\n    created_at: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n        description="Commit timestamp"\n    )\n\n    def to_summary(self) -> Dict[str, Any]:\n        """Return a summary without full file contents for listing"""\n        return {\n            "id": self.id,\n            "project_id": self.project_id,\n            "message": self.message,\n            "author_id": self.author_id,\n            "author_email": self.author_email,\n            "parent_id": self.parent_id,\n            "files_count": len(self.files_snapshot),\n            "diff_summary": {\n                "added": len(self.diff.get("added", [])),\n                "modified": len(self.diff.get("modified", [])),\n                "deleted": len(self.diff.get("deleted", [])),\n            },\n            "created_at": self.created_at.isoformat() if isinstance(self.created_at, datetime) else self.created_at,\n        }\n\n\nclass VersionControlService:\n    """\n    Service de version control Git-like pour les projets Devora.\n\n    Provides Git-like version control functionality:\n    - commit(): Create a new commit with current file state\n    - get_history(): Retrieve commit history for a project\n    - get_latest_commit(): Get the most recent commit\n    - restore(): Restore files to a specific commit state\n    - get_diff(): Get detailed diff for a commit\n    - compare_commits(): Compare two commits directly\n\n    Example usage:\n        ```python\n        vc_service = VersionControlService(db)\n\n        # Create a commit\n        commit = await vc_service.commit(\n            project_id="proj_123",\n            message="Add login functionality",\n            files=[{"name": "auth.py", "content": "...", "language": "python"}],\n            author_id="user_456"\n        )\n\n        # Get history\n        history = await vc_service.get_history("proj_123")\n\n        # Restore to previous version\n        files = await vc_service.restore(commit.id)\n        ```\n    """\n\n    def __init__(self, db: AsyncIOMotorDatabase):\n        """\n        Initialize the version control service.\n\n        Args:\n            db: AsyncIOMotorDatabase instance for MongoDB operations\n        """\n        self.db = db\n        self.commits_collection = db.commits\n\n    async def ensure_indexes(self) -> None:\n        """Create necessary indexes for optimal query performance"""\n        try:\n            # Index for querying commits by project (most common query)\n            await self.commits_collection.create_index(\n                [("project_id", 1), ("created_at", -1)],\n                name="project_commits_idx"\n            )\n            # Index for looking up commits by ID\n            await self.commits_collection.create_index(\n                "id",\n                unique=True,\n                name="commit_id_idx"\n            )\n            # Index for parent chain traversal\n            await self.commits_collection.create_index(\n                "parent_id",\n                name="parent_commit_idx"\n            )\n            logger.info("Version control indexes created successfully")\n        except Exception as e:\n            logger.warning(f"Error creating indexes (may already exist): {e}")\n\n    async def commit(\n        self,\n        project_id: str,\n        message: str,\n        files: List[Dict[str, Any]],\n        author_id: str,\n        author_email: Optional[str] = None\n    ) -> Commit:\n        """\n        Create a new commit with the current file state.\n\n        This is the primary method for saving a version of the project.\n        It automatically calculates the diff from the parent commit.\n\n        Args:\n            project_id: The project to commit to\n            message: Descriptive commit message\n            files: List of file dicts with 'name', 'content', and optionally 'language'\n            author_id: ID of the user making the commit\n            author_email: Optional email of the author\n\n        Returns:\n            The created Commit object\n\n        Raises:\n            ValueError: If project_id or message is empty\n        """\n        if not project_id or not project_id.strip():\n            raise ValueError("project_id is required")\n        if not message or not message.strip():\n            raise ValueError("Commit message is required")\n\n        # Normalize files to ensure consistent structure\n        normalized_files = self._normalize_files(files)\n\n        # Retrieve the latest commit for diff calculation\n        latest = await self.get_latest_commit(project_id)\n\n        # Calculate the diff from the parent commit\n        parent_files = latest.files_snapshot if latest else []\n        diff = self._calculate_diff(parent_files, normalized_files)\n\n        # Create the commit\n        commit = Commit(\n            id=str(uuid4()),\n            project_id=project_id,\n            message=message.strip(),\n            author_id=author_id,\n            author_email=author_email,\n            parent_id=latest.id if latest else None,\n            files_snapshot=normalized_files,\n            diff=diff,\n            created_at=datetime.now(timezone.utc)\n        )\n\n        # Serialize for MongoDB\n        doc = commit.model_dump()\n        doc['created_at'] = doc['created_at'].isoformat()\n\n        await self.commits_collection.insert_one(doc)\n\n        logger.info(\n            f"Created commit {commit.id[:8]} for project {project_id}: "\n            f"+{len(diff['added'])} ~{len(diff['modified'])} -{len(diff['deleted'])}"\n        )\n\n        return commit\n\n    async def get_history(\n        self,\n        project_id: str,\n        limit: int = 50,\n        skip: int = 0,\n        include_files: bool = False\n    ) -> List[Dict[str, Any]]:\n        """\n        Retrieve commit history for a project.\n\n        Args:\n            project_id: The project to get history for\n            limit: Maximum number of commits to return (default 50, max 100)\n            skip: Number of commits to skip for pagination\n            include_files: If True, include full file snapshots (can be large)\n\n        Returns:\n            List of commit summaries (or full commits if include_files=True)\n        """\n        limit = min(limit, 100)  # Cap at 100 for performance\n\n        projection = {"_id": 0}\n        if not include_files:\n            projection["files_snapshot"] = 0\n\n        cursor = self.commits_collection.find(\n            {"project_id": project_id},\n            projection\n        ).sort("created_at", -1).skip(skip).limit(limit)\n\n        commits = await cursor.to_list(limit)\n\n        # Parse dates\n        for commit in commits:\n            if isinstance(commit.get('created_at'), str):\n                commit['created_at'] = datetime.fromisoformat(\n                    commit['created_at'].replace('Z', '+00:00')\n                )\n\n        return commits\n\n    async def get_latest_commit(self, project_id: str) -> Optional[Commit]:\n        """\n        Retrieve the most recent commit for a project.\n\n        Args:\n            project_id: The project to get the latest commit for\n\n        Returns:\n            The latest Commit or None if no commits exist\n        """\n        doc = await self.commits_collection.find_one(\n            {"project_id": project_id},\n            {"_id": 0},\n            sort=[("created_at", -1)]\n        )\n\n        if not doc:\n            return None\n\n        # Parse datetime\n        if isinstance(doc.get('created_at'), str):\n            doc['created_at'] = datetime.fromisoformat(\n                doc['created_at'].replace('Z', '+00:00')\n            )\n\n        return Commit(**doc)\n\n    async def get_commit(self, commit_id: str) -> Optional[Commit]:\n        """\n        Retrieve a specific commit by ID.\n\n        Args:\n            commit_id: The unique commit identifier\n\n        Returns:\n            The Commit or None if not found\n        """\n        doc = await self.commits_collection.find_one(\n            {"id": commit_id},\n            {"_id": 0}\n        )\n\n        if not doc:\n            return None\n\n        # Parse datetime\n        if isinstance(doc.get('created_at'), str):\n            doc['created_at'] = datetime.fromisoformat(\n                doc['created_at'].replace('Z', '+00:00')\n            )\n\n        return Commit(**doc)\n\n    async def restore(self, commit_id: str) -> List[Dict[str, Any]]:\n        """\n        Restore files to a specific commit state.\n\n        This returns the file snapshot from the commit, which can then\n        be used to update the project's current files.\n\n        Args:\n            commit_id: The commit to restore to\n\n        Returns:\n            List of file dicts from the commit\n\n        Raises:\n            ValueError: If the commit is not found\n        """\n        commit = await self.get_commit(commit_id)\n\n        if not commit:\n            raise ValueError(f"Commit {commit_id} not found")\n\n        logger.info(f"Restored {len(commit.files_snapshot)} files from commit {commit_id[:8]}")\n\n        return commit.files_snapshot\n\n    async def get_diff(self, commit_id: str) -> Dict[str, Any]:\n        """\n        Get the detailed diff for a specific commit.\n\n        Args:\n            commit_id: The commit to get the diff for\n\n        Returns:\n            The diff dict with 'added', 'modified', 'deleted', 'unchanged'\n\n        Raises:\n            ValueError: If the commit is not found\n        """\n        commit = await self.get_commit(commit_id)\n\n        if not commit:\n            raise ValueError(f"Commit {commit_id} not found")\n\n        return commit.diff\n\n    async def compare_commits(\n        self,\n        from_commit_id: str,\n        to_commit_id: str\n    ) -> Dict[str, Any]:\n        """\n        Compare two commits and return the diff between them.\n\n        Args:\n            from_commit_id: The base commit (older)\n            to_commit_id: The target commit (newer)\n\n        Returns:\n            Diff between the two commits\n\n        Raises:\n            ValueError: If either commit is not found\n        """\n        from_commit = await self.get_commit(from_commit_id)\n        to_commit = await self.get_commit(to_commit_id)\n\n        if not from_commit:\n            raise ValueError(f"Commit {from_commit_id} not found")\n        if not to_commit:\n            raise ValueError(f"Commit {to_commit_id} not found")\n\n        return self._calculate_diff(\n            from_commit.files_snapshot,\n            to_commit.files_snapshot\n        )\n\n    async def get_commit_count(self, project_id: str) -> int:\n        """\n        Get the total number of commits for a project.\n\n        Args:\n            project_id: The project to count commits for\n\n        Returns:\n            Number of commits\n        """\n        return await self.commits_collection.count_documents({"project_id": project_id})\n\n    async def get_file_history(\n        self,\n        project_id: str,\n        file_name: str,\n        limit: int = 20\n    ) -> List[Dict[str, Any]]:\n        """\n        Get the history of changes for a specific file.\n\n        Args:\n            project_id: The project containing the file\n            file_name: The name/path of the file\n            limit: Maximum number of versions to return\n\n        Returns:\n            List of dicts with commit info and file content for each version\n        """\n        cursor = self.commits_collection.find(\n            {"project_id": project_id},\n            {"_id": 0}\n        ).sort("created_at", -1)\n\n        file_history = []\n        previous_content = None\n\n        async for doc in cursor:\n            # Find the file in this commit\n            file_snapshot = None\n            for f in doc.get('files_snapshot', []):\n                if f.get('name') == file_name:\n                    file_snapshot = f\n                    break\n\n            # Track when file was added/modified/deleted\n            current_content = file_snapshot.get('content') if file_snapshot else None\n\n            if current_content != previous_content:\n                entry = {\n                    "commit_id": doc['id'],\n                    "commit_message": doc['message'],\n                    "author_id": doc['author_id'],\n                    "created_at": doc['created_at'],\n                    "file_exists": file_snapshot is not None,\n                    "content": current_content,\n                }\n\n                if file_snapshot is None and previous_content is not None:\n                    entry["change_type"] = "deleted"\n                elif previous_content is None and current_content is not None:\n                    entry["change_type"] = "added"\n                else:\n                    entry["change_type"] = "modified"\n\n                file_history.append(entry)\n                previous_content = current_content\n\n                if len(file_history) >= limit:\n                    break\n\n        return file_history\n\n    def _normalize_files(self, files: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        """\n        Normalize file dicts to ensure consistent structure.\n\n        Args:\n            files: Raw file list\n\n        Returns:\n            Normalized file list with consistent keys\n        """\n        normalized = []\n        for f in files:\n            normalized.append({\n                "name": f.get("name", ""),\n                "content": f.get("content", ""),\n                "language": f.get("language", self._detect_language(f.get("name", "")))\n            })\n        return normalized\n\n    def _detect_language(self, filename: str) -> str:\n        """Detect programming language from file extension"""\n        ext_map = {\n            ".py": "python",\n            ".js": "javascript",\n            ".ts": "typescript",\n            ".tsx": "typescript",\n            ".jsx": "javascript",\n            ".html": "html",\n            ".css": "css",\n            ".json": "json",\n            ".md": "markdown",\n            ".sql": "sql",\n            ".sh": "bash",\n            ".yaml": "yaml",\n            ".yml": "yaml",\n        }\n\n        for ext, lang in ext_map.items():\n            if filename.lower().endswith(ext):\n                return lang\n        return "text"\n\n    def _calculate_diff(\n        self,\n        old_files: List[Dict[str, Any]],\n        new_files: List[Dict[str, Any]]\n    ) -> Dict[str, Any]:\n        """\n        Calculate the diff between two file snapshots.\n\n        Uses Python's difflib for unified diff generation.\n\n        Args:\n            old_files: Previous file state\n            new_files: Current file state\n\n        Returns:\n            Dict with 'added', 'modified', 'deleted', 'unchanged', and 'stats'\n        """\n        old_map = {f.get("name", ""): f.get("content", "") for f in old_files if f.get("name")}\n        new_map = {f.get("name", ""): f.get("content", "") for f in new_files if f.get("name")}\n\n        diff = {\n            "added": [],\n            "modified": [],\n            "deleted": [],\n            "unchanged": [],\n            "stats": {\n                "files_changed": 0,\n                "additions": 0,\n                "deletions": 0\n            }\n        }\n\n        # Process new/modified files\n        for name, content in new_map.items():\n            if name not in old_map:\n                # New file\n                diff["added"].append(name)\n                diff["stats"]["files_changed"] += 1\n                diff["stats"]["additions"] += len(content.splitlines())\n            elif old_map[name] != content:\n                # Modified file - compute unified diff\n                old_lines = old_map[name].splitlines(keepends=True)\n                new_lines = content.splitlines(keepends=True)\n\n                unified_diff = list(difflib.unified_diff(\n                    old_lines,\n                    new_lines,\n                    fromfile=f"a/{name}",\n                    tofile=f"b/{name}",\n                    lineterm=""\n                ))\n\n                # Count additions and deletions\n                additions = sum(1 for line in unified_diff if line.startswith('+') and not line.startswith('+++'))\n                deletions = sum(1 for line in unified_diff if line.startswith('-') and not line.startswith('---'))\n\n                diff["modified"].append({\n                    "name": name,\n                    "diff_lines": unified_diff,\n                    "additions": additions,\n                    "deletions": deletions\n                })\n\n                diff["stats"]["files_changed"] += 1\n                diff["stats"]["additions"] += additions\n                diff["stats"]["deletions"] += deletions\n            else:\n                # Unchanged\n                diff["unchanged"].append(name)\n\n        # Process deleted files\n        for name in old_map:\n            if name not in new_map:\n                diff["deleted"].append(name)\n                diff["stats"]["files_changed"] += 1\n                diff["stats"]["deletions"] += len(old_map[name].splitlines())\n\n        return diff\n\n\n# Factory function for easy service creation\ndef create_version_control_service(db: AsyncIOMotorDatabase) -> VersionControlService:\n    """\n    Factory function to create a VersionControlService instance.\n\n    Args:\n        db: AsyncIOMotorDatabase instance\n\n    Returns:\n        Configured VersionControlService\n    """\n    return VersionControlService(db)\n